'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var React__default = _interopDefault(React);
var uuidv4 = _interopDefault(require('uuid/v4'));
var cx = _interopDefault(require('classnames/bind'));
var PropTypes = _interopDefault(require('prop-types'));
var reactTransitionGroup = require('react-transition-group');

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function styleInject(css, ref) {
  if ( ref === void 0 ) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') { return; }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css = ".Toast__toast__LrcWv {\r\n  position: relative;\r\n  color: #fff;\r\n  margin-bottom: 10px;\r\n  min-height: 40px;\r\n  padding: 7px 15px;\r\n  min-width: 170px;\r\n  text-align: center;\r\n  display: flex;\r\n  justify-content: center;\r\n  align-content: center;\r\n  flex-direction: column;\r\n  box-shadow: 5px 6px 8px -6px #777;\r\n}\r\n\r\n.Toast__customToast__3fzIH {\r\n  position: relative;\r\n}\r\n\r\n.Toast__toastClickable__1TR2n {\r\n  cursor: pointer;\r\n}\r\n\r\n.Toast_default__ieD6B {\r\n  color: #000;\r\n  background-color: #fff;\r\n}\r\n\r\n.Toast__toastClickable__1TR2n.Toast_default__ieD6B:hover {\r\n  background-color: #e8e8e8;\r\n}\r\n\r\n.Toast_info__2mAlf {\r\n  background-color: #3498db;\r\n}\r\n\r\n.Toast__toastClickable__1TR2n.Toast_info__2mAlf:hover {\r\n  background-color: #1b92e2;\r\n}\r\n\r\n.Toast_success__2Sgma {\r\n  background-color: #07bc0c;\r\n}\r\n\r\n.Toast__toastClickable__1TR2n.Toast_success__2Sgma:hover {\r\n  background-color: #00af05;\r\n}\r\n\r\n.Toast_warning__2B3g6 {\r\n  background-color: #f1c40f;\r\n}\r\n\r\n.Toast__toastClickable__1TR2n.Toast_warning__2B3g6:hover {\r\n  background-color: #efb800;\r\n}\r\n\r\n.Toast_error__2BZ5I {\r\n  background-color: #e74c3c;\r\n}\r\n\r\n.Toast__toastClickable__1TR2n.Toast_error__2BZ5I:hover {\r\n  background: #e42f1c;\r\n}\r\n\r\n.Toast__closeButton__2kxMd {\r\n  position: absolute;\r\n  top: 0px;\r\n  right: 3px;\r\n  font-size: 12px;\r\n  cursor: pointer;\r\n}\r\n";
styleInject(css);

const ADD_TOAST = 'ADD_TOAST';
const REMOVE_TOAST = 'REMOVE_TOASTs';
const UPDATE_ALL = 'UPDATE_ALL';
const UPDATE_TOAST = 'UPDATE_TOAST';
const UPDATE_SOME = 'UPDATE_SOME';
const POSITION = {
  TOP_LEFT: 'top-left',
  TOP_RIGHT: 'top-right',
  TOP_CENTER: 'top-center',
  BOTTOM_LEFT: 'bottom-left',
  BOTTOM_RIGHT: 'bottom-right',
  BOTTOM_CENTER: 'bottom-center'
};
const TYPE = {
  INFO: 'info',
  SUCCESS: 'success',
  WARNING: 'warning',
  ERROR: 'error',
  DEFAULT: 'default',
  CUSTOM: 'custom'
};
const TRANSITION_TYPE = {
  SLIDE: 'slide',
  FADE: 'fade',
  UNFOLD: 'unfold',
  ZOOM: 'zoom',
  CUSTOM: 'custom'
};

var transitionCreate = ((type, durations, position, isCustomPosition) => {
  const styles = {
    entering: {},
    entered: {},
    exiting: {}
  };

  if (type === TRANSITION_TYPE.SLIDE) {
    if (!isCustomPosition) {
      const targetPosition = position.split('-');

      if (targetPosition[1] === 'left' || targetPosition[1] === 'right') {
        styles.entering[targetPosition[1]] = 'calc(-100% - 1em)';
        styles.entered[targetPosition[1]] = 0;
        styles.exiting[targetPosition[1]] = 'calc(-100% - 1em)';
        styles.entered.transition = `${targetPosition[1]} ${durations.enter}ms linear`;
        styles.exiting.transition = `${targetPosition[1]} ${durations.exit}ms linear`;
      } else {
        styles.entering[targetPosition[0]] = 'calc(-100% - 1em)';
        styles.entered[targetPosition[0]] = 0;
        styles.exiting[targetPosition[0]] = 'calc(-100% - 1em)';
        styles.entered.transition = `${targetPosition[0]} ${durations.enter}ms linear`;
        styles.exiting.transition = `${targetPosition[0]} ${durations.exit}ms linear`;
      }
    }
  } else if (type === TRANSITION_TYPE.FADE) {
    styles.entering.opacity = 0;
    styles.entered.opacity = 1;
    styles.exiting.opacity = 0;
    styles.entered.transition = `opacity ${durations.enter}ms linear`;
    styles.exiting.transition = `opacity ${durations.exit}ms linear`;
  } else if (type === TRANSITION_TYPE.UNFOLD) {
    styles.entering.opacity = 0;
    styles.entering.transform = 'rotateY(-180deg)';
    styles.entered.opacity = 1;
    styles.entered.transform = 'rotateY(0deg)';
    styles.exiting.opacity = 0;
    styles.exiting.transform = 'rotateY(-180deg)';
    styles.entered.transition = `all ${durations.enter}ms linear`;
    styles.exiting.transition = `all ${durations.exit}ms linear`;
  } else if (type === TRANSITION_TYPE.ZOOM) {
    styles.entering.transform = 'scale(0)';
    styles.entered.transform = 'scale(1)';
    styles.exiting.transform = 'scale(0)';
    styles.entered.transition = `all ${durations.enter}ms linear`;
    styles.exiting.transition = `all ${durations.exit}ms linear`;
  }

  return styles;
});

const Toast = props => {
  const {
    id,
    classNames,
    content,
    clickToClose,
    closeButton,
    customTransitions,
    triggerIn,
    duration,
    position,
    type,
    transition,
    onClick
  } = props,
        cssTransitionOptions = _objectWithoutPropertiesLoose(props, ["id", "classNames", "content", "clickToClose", "closeButton", "customTransitions", "triggerIn", "duration", "position", "type", "transition", "onClick"]);

  const [transitionIn, setIn] = React.useState(triggerIn);
  React.useEffect(() => {
    setIn(triggerIn);
  }, [triggerIn]);
  let timeout;

  if (transitionIn && duration) {
    setTimeout(() => {
      setIn(false);
    }, duration);
  }

  const manualClose = e => {
    e.stopPropagation();

    if (transitionIn) {
      clearTimeout(timeout);
      setIn(false);
    }
  };

  let className = cx(classNames, {
    _toastClickable: clickToClose
  });

  if (type === TYPE.CUSTOM) {
    className = cx('_blank', className);
  } else {
    className = cx(type, '_toast', className);
  }

  const styles = React.useMemo(() => transitionCreate(transition.type, transition.durations, position, typeof position === 'object'), [transition, type]);

  if (type === TYPE.CUSTOM) {
    cssTransitionOptions.classNames = customTransitions;
  }

  const toastEventHandlers = {};

  if (onClick) {
    toastEventHandlers.onClick = () => onClick(id);
  } else if (clickToClose) {
    toastEventHandlers.onClick = e => manualClose(e);
  }

  return React__default.createElement(reactTransitionGroup.CSSTransition, _extends({
    in: transitionIn,
    appear: true,
    timeout: transition.durations
  }, cssTransitionOptions), state => React__default.createElement("li", _extends({
    role: "alert",
    className: className,
    style: styles[state]
  }, toastEventHandlers), content, closeButton && React__default.createElement("span", {
    className: "_closeButton",
    onClick: manualClose
  }, "\u2716")));
};

Toast.propTypes = {
  id: PropTypes.string,
  classNames: PropTypes.string,
  content: PropTypes.node.isRequired,
  customTransitions: PropTypes.object,
  type: PropTypes.oneOf([TYPE.DEFAULT, TYPE.INFO, TYPE.SUCCESS, TYPE.WARNING, TYPE.ERROR, TYPE.CUSTOM]),
  position: PropTypes.oneOfType([PropTypes.oneOf([POSITION.TOP_LEFT, POSITION.TOP_RIGHT, POSITION.TOP_CENTER, POSITION.BOTTOM_LEFT, POSITION.BOTTOM_RIGHT, POSITION.BOTTOM_CENTER]), PropTypes.shape({
    top: PropTypes.string,
    bottom: PropTypes.string,
    left: PropTypes.string,
    right: PropTypes.string
  })]),
  duration: PropTypes.oneOfType([PropTypes.number, PropTypes.oneOf([false])]),
  clickToClose: PropTypes.bool,
  onClick: PropTypes.func,
  closeButton: PropTypes.bool,
  triggerIn: PropTypes.bool,
  transition: PropTypes.shape({
    type: PropTypes.oneOf([TRANSITION_TYPE.SLIDE, TRANSITION_TYPE.FADE, TRANSITION_TYPE.UNFOLD, TRANSITION_TYPE.ZOOM, TRANSITION_TYPE.CUSTOM]),
    durations: PropTypes.shape({
      appear: PropTypes.number,
      enter: PropTypes.number,
      exit: PropTypes.number
    })
  })
};
Toast.defaultProps = {
  classNames: '',
  type: TYPE.DEFAULT,
  position: POSITION.BOTTOM_RIGHT,
  duration: 5000,
  clickToClose: true,
  closeButton: true,
  customTransitions: {},
  triggerIn: true,
  transition: {
    type: TRANSITION_TYPE.SLIDE,
    durations: {
      appear: 0,
      enter: 400,
      exit: 400
    }
  }
};

var ToastReducer = ((state, action) => {
  let newState = state;

  switch (action.type) {
    case ADD_TOAST:
      {
        let addContainer = false;
        let containerFound = false;
        newState = state.map((toastContainer, i) => {
          if (toastContainer.position === action.payload.position) {
            containerFound = true;
            return Object.assign(Object.assign({}, toastContainer), {
              toasts: [...newState[i].toasts, action.payload]
            });
          }

          if (i === state.length - 1 && !containerFound) {
            addContainer = true;
          }

          return toastContainer;
        });

        if (addContainer || state.length === 0) {
          return [...state, {
            id: uuidv4(),
            position: action.payload.position,
            toasts: [action.payload]
          }];
        }

        return newState;
      }

    case REMOVE_TOAST:
      {
        let removeContainer = false;
        newState = state.map(toastContainer => {
          if (toastContainer.position === action.payload.position) {
            const newToastList = toastContainer.toasts.filter(toast => {
              if (toast.id === action.payload.id) {
                if (toastContainer.toasts.length === 1) removeContainer = toastContainer;
                return false;
              }

              return true;
            });
            return Object.assign({}, toastContainer, {
              toasts: newToastList
            });
          }

          return toastContainer;
        });

        if (removeContainer) {
          newState = state.filter(toastContainer => toastContainer !== removeContainer);
        }

        return newState;
      }

    case UPDATE_TOAST:
      return state.map(toastContainer => Object.assign({}, toastContainer, {
        toasts: toastContainer.toasts.map(toast => {
          if (toast.id === action.payload.id) return Object.assign({}, toast, action.payload);
          return toast;
        })
      }));

    case UPDATE_SOME:
      newState = state.map(toastContainer => Object.assign({}, toastContainer, {
        toasts: toastContainer.toasts.map(toast => {
          let updatedToast = toast;
          action.payload.forEach(updateData => {
            if (updateData.id === toast.id) {
              updatedToast = Object.assign({}, updatedToast, updateData);
            }
          });
          return updatedToast;
        })
      }));
      return newState;

    case UPDATE_ALL:
      return state.map(toastContainer => Object.assign({}, toastContainer, {
        toasts: toastContainer.toasts.map(toast => {
          return Object.assign({}, toast, action.payload);
        })
      }));

    default:
  }
});

var css$1 = ".Toaster__toaster__hyBJU {\r\n  position: fixed;\r\n  display: flex;\r\n  list-style-type: none;\r\n  padding: 0;\r\n  margin: 0;\r\n  height: fit-content;\r\n  z-index: 99999;\r\n}\r\n\r\n.Toaster_bottom-right__yX5qT {\r\n  flex-flow: column-reverse nowrap;\r\n  align-items: flex-end;\r\n  bottom: 1em;\r\n  right: 1em;\r\n}\r\n\r\n.Toaster_bottom-left__36-0j {\r\n  flex-flow: column-reverse nowrap;\r\n  align-items: flex-start;\r\n  bottom: 1em;\r\n  left: 1em;\r\n}\r\n\r\n.Toaster_bottom-center__g1j2r {\r\n  flex-flow: column-reverse nowrap;\r\n  align-items: center;\r\n  bottom: 1em;\r\n  left: 50%;\r\n  transform: translateX(-50%);\r\n}\r\n\r\n.Toaster_top-right__1_Kbn {\r\n  flex-flow: column-reverse nowrap;\r\n  align-items: flex-end;\r\n  top: 1em;\r\n  right: 1em;\r\n}\r\n\r\n.Toaster_top-left__2khU1 {\r\n  flex-flow: column nowrap;\r\n  align-items: flex-start;\r\n  top: 1em;\r\n  left: 1em;\r\n}\r\n\r\n.Toaster_top-center__3XE4g {\r\n  flex-flow: column nowrap;\r\n  align-items: flex-end;\r\n  left: 50%;\r\n  transform: translateX(-50%);\r\n}\r\n";
styleInject(css$1);

const Toaster = (_ref) => {
  let {
    children,
    context
  } = _ref,
      defaultToastOptions = _objectWithoutPropertiesLoose(_ref, ["children", "context"]);

  const ToasterContext = context;
  const [toastContainerList, dispatch] = React.useReducer(ToastReducer, []);

  const buildToast = (content, options = {}) => {
    const newToast = Object.assign({}, {
      id: uuidv4(),
      content
    }, defaultToastOptions, options);

    if (!newToast.position) {
      newToast.position = POSITION.BOTTOM_RIGHT;
    } else if (!Object.values(POSITION).includes(newToast.position) && typeof newToast.position !== 'object') {
      throw new TypeError('Position Property Is Invalid!');
    }

    dispatch({
      type: ADD_TOAST,
      payload: newToast
    });
    return newToast.id;
  };

  buildToast.TYPE = TYPE;
  buildToast.POSITION = POSITION;
  buildToast.TRANSITION_TYPE = TRANSITION_TYPE;

  buildToast.update = (id, updates) => updateToast(id, updates);

  buildToast.updateAll = updates => updateAll(updates);

  buildToast.dismiss = id => dissmiss(id);

  buildToast.dismissAll = () => dissmissAll();

  buildToast.updateSome = updateList => updateSome(updateList);

  const removeToast = toast => {
    dispatch({
      type: REMOVE_TOAST,
      payload: toast
    });
  };

  const dissmiss = toastId => {
    updateToast(toastId, {
      triggerIn: false
    });
  };

  const dissmissAll = () => updateAll({
    triggerIn: false
  });

  const updateAll = updates => {
    dispatch({
      type: UPDATE_ALL,
      payload: updates
    });
  };

  const updateToast = (id, updates) => {
    dispatch({
      type: UPDATE_TOAST,
      payload: Object.assign({
        id
      }, updates)
    });
  };

  const updateSome = updateList => {
    dispatch({
      type: UPDATE_SOME,
      payload: updateList
    });
  };

  const renderToasts = toastList => toastList.map(toast => React__default.createElement(Toast, _extends({
    key: toast.id,
    onExited: () => removeToast(toast)
  }, toast)));

  const renderContainers = () => toastContainerList.map(toastContainer => {
    if (typeof toastContainer.position === 'object') {
      return React__default.createElement("ul", {
        key: toastContainer.id,
        className: "_toaster",
        style: toastContainer.position
      }, renderToasts(toastContainer.toasts));
    }

    return React__default.createElement("ul", {
      key: toastContainer.id,
      className: cx('_toaster', toastContainer.position)
    }, renderToasts(toastContainer.toasts));
  });

  return React__default.createElement(ToasterContext.Provider, {
    value: React.useCallback(buildToast, [])
  }, React__default.createElement(React__default.Fragment, null, children, renderContainers()));
};

Toaster.propTypes = {
  children: PropTypes.node,
  context: PropTypes.object.isRequired,
  classNames: PropTypes.string,
  customTransitions: PropTypes.object,
  type: PropTypes.oneOf([TYPE.DEFAULT, TYPE.INFO, TYPE.SUCCESS, TYPE.WARNING, TYPE.ERROR, TYPE.CUSTOM]),
  position: PropTypes.oneOfType([PropTypes.oneOf([POSITION.TOP_LEFT, POSITION.TOP_RIGHT, POSITION.TOP_CENTER, POSITION.BOTTOM_LEFT, POSITION.BOTTOM_RIGHT, POSITION.BOTTOM_CENTER]), PropTypes.shape({
    top: PropTypes.string,
    bottom: PropTypes.string,
    left: PropTypes.string,
    right: PropTypes.string
  })]),
  duration: PropTypes.oneOfType([PropTypes.number, PropTypes.oneOf([false])]),
  clickToClose: PropTypes.bool,
  onClick: PropTypes.func,
  closeButton: PropTypes.bool,
  triggerIn: PropTypes.bool,
  transition: PropTypes.shape({
    type: PropTypes.oneOf([TRANSITION_TYPE.SLIDE, TRANSITION_TYPE.FADE, TRANSITION_TYPE.UNFOLD, TRANSITION_TYPE.ZOOM, TRANSITION_TYPE.CUSTOM]),
    durations: PropTypes.shape({
      appear: PropTypes.number,
      enter: PropTypes.number,
      exit: PropTypes.number
    })
  })
};
var Toaster$1 = React__default.memo(Toaster);

module.exports = Toaster$1;
